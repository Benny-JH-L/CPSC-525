
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 3 solution explanation
========================================================================

### how I found the vulnerability
* I analyzed the vulnerable program's source code `task3-vuln.c` and found that
    the password information (its start index in `giant_string` and length) is
    stored in a variable `secret_pos[2]`.

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`
    in `gdb`, and used commands ("p secret_pos") to grab the `secret_pos` variable information.
* Then I obtained the password by using the information obtained from `gdb` while 
    filtering out non-alphanumeric characters.
* I send in the password and retrieve the hidden password.
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"

GIANT_STRING = "\
Security through obscurity From Wikipedia, the free encyclopedia \
Security through obscurity should not be used as the only security \
feature of a system.  In security engineering, security through \
obscurity is the practice of concealing the details or mechanisms of a \
system to enhance its security. This approach relies on the principle \
of hiding something in plain sight, akin to a magician's sleight of \
hand or the use of camouflage. It diverges from traditional security \
methods, such as physical locks, and is more about obscuring \
information or characteristics to deter potential threats. Examples of \
this practice include disguising sensitive information within \
commonplace items, like a piece of paper in a book, or altering digital \
footprints, such as spoofing a web browser's version number. While not a \
standalone solution, security through obscurity can complement other security \
measures in certain scenarios.[1] Obscurity in the context of security \
engineering is the notion that information can be protected, to a certain \
extent, when it is difficult to access or comprehend. This concept hinges \
on the principle of making the details or workings of a system less visible \
or understandable, thereby reducing the likelihood of unauthorizedaccess \
or manipulation.[2] History An early opponent of security through obscurity \
was the locksmith Alfred Charles Hobbs, who in 1851 demonstrated to the \
public how state-of-the-art locks could be picked. In response to concerns \
that exposing security flaws in the design of locks could make them more \
vulnerable to criminals, he said: 'Rogues are very keen in their \
profession, and know already much more than we can teach them.'[3] \
There is scant formal literature on the issue of security through \
obscurity. Books on security engineering cite Kerckhoffs' doctrine from 1883,\
 if they cite anything at all. For example, in a discussion about secrecy \
 and openness in nuclear command and control: [T]he benefits of reducing \
 the likelihood of an accidental war were considered to outweigh the \
 possible benefits of secrecy. This is a modern reincarnation of \
 Kerckhoffs' doctrine, first put forward in the nineteenth century, \
 that the security of a system should depend on its key, not on its \
 design remaining obscure.[4] Peter Swire has written about the \
 trade-off between the notion that 'security through obscurity is \
 an illusion' and the military notion that 'loose lips sink ships',[5] \
 as well as on how competition affects the incentives to disclose.[6]\
 [further explanation needed] There are conflicting stories about \
 the origin of this term. Fans of MIT's Incompatible Timesharing \
 System (ITS) say it was coined in opposition to Multics users down \
 the hall, for whom security was far more an issue than on ITS. Within \
 the ITS culture the term referred, self-mockingly, to the poor coverage \
 of the documentation and obscurity of many commands, and to the \
 attitude that by the time a tourist figured out how to make trouble \
 he'd generally got over the urge to make it, because he felt part \
 of the community. One instance of deliberate security through obscurity \
 on ITS has been noted: the command to allow patching the running \
 ITS system (altmode altmode control-R) echoed as $$^D. Typing Alt \
 Alt Control-D set a flag that would prevent patching the system \
 even if the user later got it right.[7]\
"
# source: https://en.wikipedia.org/wiki/Security_through_obscurity (2024-06)


class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def get_password(execname):
    '''
    Extracts the password of the vulnerable program, using `gdb`
    '''        
    
    # define gdb commands to extract data from `secret_pos` variable
    cmds = []
    cmds += ["gdb"]
    cmds += ["set pagination off"]
    cmds += ["set confirm off"]
    cmds += [f"file {execname}"]
    cmds += ["b main"]
    cmds += ["start"]
    cmds += ["p secret_pos"]
    cmds += ["quit"]
    
    # works too
    # cmds += ["gdb", "-q", "-nx", "--batch"]
    # cmds += ["-ex", "set pagination off"]
    # cmds += ["-ex", "set confirm off"]
    # cmds += ["-ex", "set debuginfod enabled off"]
    # cmds += ["-ex", f"file {execname}"]
    # cmds += ["-ex", "start"]
    # cmds += ["p secret_pos"]
    # cmds += ["quit"]
    
    # start the 'gdb'
    proc = color_spawn(cmds[0], timeout=5)
    
    # send 'cmds'
    for x in range(1, len(cmds)):
        proc.sendline(cmds[x])
    
    proc.expect(pexpect.EOF, timeout=5)     # wait for EOF (wait until command finishes)
    gdb_info = proc.before.decode("ascii")  # extract 'gdb' information
    
    # print(f"\n{gdb_info}\n---size: {len(gdb_info)}")    # debug
    
    split = gdb_info.rsplit("(gdb)")    # extract 'gdb' related info into an array
    
    # get only the `gdb` line with the password info
    gdb_password_info = split[len(split) - 2].strip()
    # parse `gdb_password_info` to contain start index and length of password
    pass_start_index = ""
    pass_len = ""
    build_start = False
    build_len = False
    for x in range(0, len(gdb_password_info)):
        char = gdb_password_info[x]
        if (char == " "):
            continue
        elif (char == ',' or build_len and char != '}'):    # build the `pass_len``
            pass_len += char
            build_len = True
            build_start = False
        elif (char == '{' or build_start and char != ','):  # build the `pass_start_index`
            pass_start_index += char
            build_start = True
    
    # remove extra character at the beginning and convert to an int
    pass_start_index = int(pass_start_index[1:])
    pass_len = int(pass_len[1:])
    
    # getting the valid password
    invalid_password = GIANT_STRING[pass_start_index: pass_start_index + pass_len]
    password = ""
    # remove non alphanumeric characters
    for x in range (0, len(invalid_password)):
        char = invalid_password[x]
        # if (char >= 'a' and char <= 'z') or (char >= 'A' and char <= 'Z') or (char >= '0' and char <= '9'):
        if char.isalnum():
            password += char
    
    # debug
    # print(split)
    # print(f"pass info: `{password_info}`")
    # print(f"pass_start_index: `{pass_start_index}`")
    # print(f"pass_len: `{pass_len}`")
    # print(f"invalid pass: `{invalid_password}`")
    # print(f"password: `{password}`")
    
    proc.kill(True)
    return password
        

def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:
        password = get_password(execname)
        # print(f'---executing with pass: `{password}`') # debug
        
        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)
        
        # wait for the password prompt
        process.expect_exact("Password:")
        process.sendline(password)
                
        # recover the hidden message
        # notice that with popen_spawn we can use \n line endings
        process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        process.expect_exact("-----END HIDDEN MESSAGE-----")
        hidden_message = process.before.decode("ascii").rstrip()
        # optional: read the remaining output of the program one line at a time until <EOF>
        process.expect(pexpect.EOF, timeout=7)

        # print out the recovered hidden message
        print("Recovered hidden message:", hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])





