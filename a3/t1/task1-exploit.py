
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 1 solution explanation
========================================================================

### how I found the vulnerability
* I used the command strings(1) to find the hardcoded password's/hidden messages for the inputed executable.
* The hardcoded password was always below the line "Password matches."
* The passwords and hidden messages I recovered from the executables provided were:
    # --task1-vuln
    # Password: ThereIsNoSpoon
    # Hidden msg: Bravocado!

    # --task1-vuln2
    # Password: ThereIsNoSpoon
    # Hidden msg: Hodgepodge

    # --task1-vuln3
    # Password: ButThereIsAFork
    # Hidden msg: We found the spoon.

    # --task1-vuln4
    # Password: f0rkb0mb
    # Hidden msg: False alarm, there was no spoon.
    
* I then used the same process of how I found those passwords above to find any password for a executable into my exploit script.
* For the arbitrary password, I found that it was always under the line "-----BEGIN HIDDEN MESSAGE-----",
    so I used the same process above to find the hidden message, given an arbitrary password

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`
* I wait for the program to prompt "Password:" using `expect_exact()`
* Then I send in the hardcoded password (if it exists), found using `find_hardcoded_password()`, using `sendline()`
    * I wait for the program to output the begin hidden message prompt
        "-----BEGIN HIDDEN MESSAGE-----"
    * I wait for the program to output the end hidden message prompt
        "-----END HIDDEN MESSAGE-----"
    * I capture the hidden message that is output between the two prompts using
    `process.before` attribute
* Or I find the hidden message directly with an arbitrary password instead
* I output the recovered hidden message
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0").lower() in ["1", "y", "yes", "true", "on", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"

class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    # p = popen_spawn.PopenSpawn(*args, **kwargs, timeout=5)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")        
    return p


def find_hardcoded_password(execname):
    """
    Finds the hardcoded password of the executable `execname` using the system command `strings(1)`.
    """
    if DEBUG:
        print("using `strings()` to find hardcoded password")
    
    cmd = f"strings {execname}"             # command to execute in process
    sproc = color_spawn(cmd, timeout=5)     # make the process
    sproc.expect(pexpect.EOF, timeout=5)    # wait for EOF (command finishes)
    output = sproc.before.decode("ascii")                # contains what the command `strings <execname>` outputs
    # print(output)  #debug
    
    find_line = "Password matches." # the string before/above the password when `strings <execname>` is used
    
    curr_line = ""          # store the current line
    password_index = -1     # index of where the password starts in `output`
    
    # find the line `find_line`
    for x in range(0, len(output)):
        
        char = output[x]
        
        if (char == "\n"):  # line complete
            
            # print("curr_line = " + curr_line)   # debug
            
            if (curr_line == find_line):    # found the line
                password_index = x + 1      # set starting position
                # print("password start index: " + str(password_index))   # debug
                break
            else:
                curr_line = ""  # reset
                continue
        
        curr_line += char   # build the line
    
    hardcoded_password = ""
    
    # build the hardcoded password
    for index in range(password_index, len(output)):
        
        char = output[index]
        
        if (char == "\n"):
            break
        
        hardcoded_password += output[index]
    
    sproc.kill(True)
    # print("hardcoded password is: " + hardcoded_password)   #DEBUG
    return hardcoded_password

def find_hidden_msg(execname):
    """
    Finds the hidden message of the executable `execname` using the system command `strings(1)`.
    """
    if DEBUG:
        print("using `strings()` to find hidden message")
    
    cmd = f"strings {execname}"             # command to execute in process
    sproc = color_spawn(cmd, timeout=5)     # make the process
    sproc.expect(pexpect.EOF, timeout=5)    # wait for EOF (command finishes)
    output = sproc.before.decode("ascii")                # contains what the command `strings <execname>` outputs
    # print(output)  #debug
    
    find_line = "-----BEGIN HIDDEN MESSAGE-----" # the string before/above the hidden message when `strings <execname>` is used
    
    curr_line = ""          # store the current line
    message_index = -1      # index of where the hidden message starts in `output`
    
    # find the line `find_line`
    for x in range(0, len(output)):
        
        char = output[x]
        
        if (char == "\n"):  # line complete
            
            # print("curr_line = " + curr_line)   # debug
            
            if (curr_line == find_line):    # found the line
                message_index = x + 1      # set starting position
                # print("mesg start index: " + str(message_index))   # debug
                break
            else:
                curr_line = ""  # reset
                continue
        
        curr_line += char   # build the line
    
    hidden_message = ""
    # build the msg
    for index in range(message_index, len(output)):
        
        char = output[index]
        
        if (char == "\n"):
            break
        
        hidden_message += char
        
    sproc.kill(True)
    # print("hidden message: " + hidden_message) # debug
    return hidden_message


def main(execname):
    """exploit the vulnerable executable using pexpect"""
        
    try:     
        hidden_message = find_hidden_msg(execname)
                
        if (hidden_message == ""):      
            hardcoded_password = find_hardcoded_password(execname)  # get the hardcoded password      
            # start the vulnerable program
            process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)
            
            # tell pexpect to log all input/output from the executable to stdout
            if DEBUG:
                process.logfile = sys.stdout.buffer

            # wait for the password prompt
            process.expect_exact("Password:")

            # write the password that we found in the source code
            process.sendline(hardcoded_password)
            
            # recover the hidden message
            process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")        
            process.expect_exact("-----END HIDDEN MESSAGE-----")
            hidden_message = process.before.decode("ascii").rstrip()
            # optional: read the remaining output of the program one line at a time until <EOF>
            process.expect(pexpect.EOF, timeout=5)
            process.kill(True)
                    
        # print out the recovered hidden message
        print("Recovered hidden message:", hidden_message)
        # return
            
    except Exception:
        print("Exploit failed.")
        if DEBUG:
            raise
    
    # print("Exploit failed.")
    return

if __name__ == "__main__":
    main(sys.argv[1])
    sys.exit()

