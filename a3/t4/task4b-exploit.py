
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 4b solution explanation
========================================================================

### how I found the vulnerability
* I analyzed the vulnerable program's source code `task4b-vuln.c` and found that 
    when the code commpares the hashed password entered and the stored hash, it only compares
    the first four characters of the two strings (namely from `EVP_MAX_MD_SIZE >> 4`).
* The vulnerable program also has debug statements that outputs sensative information about the 
    stored hash and calculated hash, which can be enabled via environment variable `debughash`.

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I start the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`
* I first start the vulnerable executable to extract the `stored_pass_hash` from the debug statements that I enabled
    from the environment variable `debughash`, by setting `env "debughash=1"`. 
* I then generate all the possible 4 length string passwords (using valid characters for passwords as defined in the assignment description). 
* I then loop over the generated passwords, hashing them and comparing their first four characters of the hash with the 
    first four characters of the `stored_pass_hash`.
* Once I find the password with the same first 4-letter hash as the `stored_pass_hash`, I run the vulnerable
    program once again, entering the password found and retrieving the hidden message.
"""

import os
import sys
from pexpect import popen_spawn
import pexpect

import hashlib
import itertools
import string

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"

CHARACTERS_CHECKED = 4  # number of characters the `strncmp(...)` function checks (EVP_MAX_MD_SIZE >> 4 == 4)
VALID_PASSWORD_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' # valid characters that can be used in a password

class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


# def generate_strings(n):
#     '''
#     Generates strings of length `n` using characters defined in `VALID_PASSWORD_CHARS`.
#     Returns a list of all possible strings of length `n`.
#     '''
    
#     # base case
#     if n == 0:
#         return ['']
    
#     # recursive case: for each character, append to all strings of length n-1
#     result = []
#     for s in generate_strings(n - 1):   # get list of strings of length `n - 1`
#         for c in VALID_PASSWORD_CHARS:  # for each string add all the char's to it (ex. s = "a", then looping (s + c) will be "aa", "ab", ..., "a0", ..., "a9")
#             result.append(s + c)        # add the new string to array
    
#     return result   # return the list of all possible strings of length `n` using `VALID_PASSWORD_CHARS`

def generate_strings(n):
    '''
    Generates strings of length `n` using characters defined in `VALID_PASSWORD_CHARS`.
    '''
    for combo in itertools.product(VALID_PASSWORD_CHARS, repeat=n):
            yield ''.join(combo)

def hash_string(string):
    '''
    Returns the sha256 hash of `string`.
    '''
    return hashlib.sha256(string.encode()).hexdigest()


def get_stored_hash(execname):
    '''
    Gets the `stored_pass_hash` inside the vulnerable program `execname` and returns it.
    '''
    os.environ["debughash"] = "1"   # set the environment variable to true
    
    proc = color_spawn(f"stdbuf -o0 {execname}", timeout=5)

    # wait for the password prompt
    proc.expect_exact("Debug mode active.\n")
    proc.expect_exact("Password:")
    msg = proc.before.decode("ascii").rstrip()  # get stored hash from debug statement

    proc.sendline("")                           # send whatever
    
    proc.expect(pexpect.EOF, timeout=8)
    
    # other = proc.before.decode("ascii").rstrip()
    
    stored_hash = msg.split(" ")
    stored_hash = stored_hash[len(stored_hash) - 1]
    
    # debug
    # print(f"---message: `{msg}`") 
    # print(f"---stored hash: `{stored_hash}`") 
    # print(f"---other: `{other}`") 
    
    del os.environ["debughash"]     # delete the environment variable (set to null)

    return stored_hash


def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:
        stored_hash = get_stored_hash(execname)
        stored_hash_first4 = stored_hash[0:CHARACTERS_CHECKED]
        passwords_to_try_array = generate_strings(CHARACTERS_CHECKED)
        
        # debug
        # print(passwords_to_try_array)
        # print(f"---stored hash (full): {stored_hash} | stored hash (first 4 chars): {stored_hash_first4}")
        # print(f"num of pass to try: {len(passwords_to_try_array)}") # this is going to be 14 776 336 elements...
        # print(f'hashing `{passwords_to_try_array[0]}`: {hash_string(passwords_to_try_array[0])}') # my hash of 'aaaa' is "61be55a8e2f6b4e172338bddf184d6dbee29c98853e0a0485ecee7f27b9af0b4", the c programs hash is "61be55a8e2f6b4e172338bddf184d6dbee29c98853e0a0485ecee7f27b9af0b4" too!
        
        password = ""
        
        # go though each of my generated passwords in `passwords_to_try_array` until we find the one that shares the same first 4 hash characters
        for pass_to_hash in passwords_to_try_array:                         # get the password to be hashed
            
            # hash `pass_to_hash` and check if its first 4 chararacters match `stored_hash_first4`
            if (hash_string(pass_to_hash)[0:CHARACTERS_CHECKED] == stored_hash_first4):
                # print(f"FOUND THE RIGHT PASS! pass: `{pass_to_hash}`") # debug
                password = pass_to_hash                                     # set the password we found matching the first 4 character stored hash
                break
        
        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)
        
        # wait for the password prompt
        process.expect_exact("Password:")
        # send in password
        process.sendline(password)
        
        # recover the hidden message
        # notice that with popen_spawn we can use \n line endings
        process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        process.expect_exact("-----END HIDDEN MESSAGE-----")
        hidden_message = process.before.decode("ascii").rstrip()
        # optional: read the remaining output of the program one line at a time until <EOF>
        process.expect(pexpect.EOF, timeout=8)

        # print out the recovered hidden message
        print("Recovered hidden message:", hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
