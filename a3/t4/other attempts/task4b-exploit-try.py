
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 4b solution explanation
========================================================================

### how I found the vulnerability
* 

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`

"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"

class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def find_hidden_msg(execname):
    """
    Finds the hidden message of the executable `execname` using the system command `strings(1)`.
    """
    if DEBUG:
        print("using `strings()` to find hidden message")
    
    cmd = f"strings {execname}"             # command to execute in process
    sproc = color_spawn(cmd, timeout=5)     # make the process
    sproc.expect(pexpect.EOF, timeout=5)    # wait for EOF (command finishes)
    output = sproc.before.decode("ascii")                # contains what the command `strings <execname>` outputs
    # print(output)  #debug
    
    find_line = "-----BEGIN HIDDEN MESSAGE-----" # the string before/above the hidden message when `strings <execname>` is used
    
    curr_line = ""          # store the current line
    message_index = -1      # index of where the hidden message starts in `output`
    
    # find the line `find_line`
    for x in range(0, len(output)):
        
        char = output[x]
        
        if (char == "\n"):  # line complete
            
            # print("curr_line = " + curr_line)   # debug
            
            if (curr_line == find_line):    # found the line
                message_index = x + 1      # set starting position
                # print("mesg start index: " + str(message_index))   # debug
                break
            else:
                curr_line = ""  # reset
                continue
        
        curr_line += char   # build the line
    
    hidden_message = ""
    # build the msg
    for index in range(message_index, len(output)):
        
        char = output[index]
        
        if (char == "\n"):
            break
        
        hidden_message += char
        
    sproc.kill(True)
    # print("hidden message: " + hidden_message) # debug
    return hidden_message
    
    
def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:
        hidden_message = find_hidden_msg(execname)
        print("Recovered hidden message:", hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
