
# Benny Liang | UCID: 30192142 | Assignment 3

"""
TASK 4b solution explanation
========================================================================

### how I found the vulnerability
* 

### how the script works
* I used `pexpect.popen_spawn.PopenSpawn` to start and to interact with the vulnerable program
* I started the vulnerable executable with a wrapper function `color_spawn()`, which calls `pexpect.popen_spawn.PopenSpawn`

"""

import os
import sys
from pexpect import popen_spawn
import pexpect

# debugging output controlled via DEBUG environment variable
DEBUG = os.environ.get("DEBUG", "0") in ["1", "color"]
DEBUG_COLOR = os.environ.get("DEBUG", "0").lower() == "color"

class ColoredLog:
    """A pexpect logfile that adds color to output."""

    def __init__(self, color="1;34"):
        self.prefix = f"\033[{color}m".encode("ascii") if DEBUG_COLOR else b""
        self.suffix = b"\033[0m" if DEBUG_COLOR else b""

    def write(self, s: bytes):
        """write() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.write(self.prefix)
            # convert s to string but escape non-printable characters with backslash escapes
            ss = ""
            for c in s:
                if chr(c) in "\\":  # escape backslash and brackets
                    ss += "\\" + chr(c)
                elif (c >= 32 and c <= 126) or (chr(c) in "\n\t"):
                    ss += chr(c)
                else:
                    ss += f"\\{c:02x}"
            sys.stdout.buffer.write(ss.encode("ascii"))
            sys.stdout.buffer.write(self.suffix)

    def flush(self):
        """flush() method for pexpect logfile interface"""
        if DEBUG:
            sys.stdout.buffer.flush()


def color_spawn(*args, **kwargs):
    """wrapper for pexpect.popen_spawn.PopenSpawn() and attaching a logger"""
    p = popen_spawn.PopenSpawn(*args, **kwargs)
    p.logfile_read = ColoredLog("1;34")
    p.logfile_send = ColoredLog("1;32")
    return p


def get_hidden_message(execname):
    '''
    Gets the hidden message in the vulnerable executable `execname` and returns it.
    '''
    
    # command to retrieve the hidden message (using `strings`)
    # cmd = f"stdbuf -o0 strings {execname}"
    cmd = f"strings {execname}"
    
    process = color_spawn(cmd, timeout=5)
    process.expect(pexpect.EOF, timeout=8)  # wait for the whole response

    full_msg = process.before.decode("ascii").rstrip()
    full_msg_array = full_msg.split("\n")   # turn the full message into an array
    
    # check if the executable exists
    exist = f"strings: '{execname}': No such file"
    if (full_msg == exist):
        raise Exception
    
    find_line = "-----BEGIN HIDDEN MESSAGE-----" # the string before/above the hidden message when `strings <execname>` is used
    hidden_message = ""
    # go through each line of the output until we find `find_line`
    for x in range(0, len(full_msg_array)):
        
        line_to_check = full_msg_array[x]
        # check if we found the line
        if (line_to_check == find_line):
            hidden_message = full_msg_array[x + 1]  # set the hidden message

    # debug
    print(f"full msg: {full_msg}")
    print(f"array ver: {full_msg_array}")
    # print(f"---hidden message: `{hidden_message}`")
    
    return hidden_message
    
    
def main(execname):
    """exploit the vulnerable executable using pexpect"""

    try:
        hidden_message = get_hidden_message(execname)
        print("Recovered hidden message:", hidden_message)

    except Exception:  # pylint: disable=broad-except
        print("Exploit failed.")
        if DEBUG:
            raise


if __name__ == "__main__":
    main(sys.argv[1])
